<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOTP Authenticator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f172a 0%, #581c87 50%, #0f172a 100%);
        }
        
        .container {
            max-width: 32rem;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        .text-center { text-align: center; }
        .font-mono { font-family: ui-monospace, SFMono-Regular, 'SF Mono', Consolas, monospace; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        
        .header-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 4rem;
            height: 4rem;
            background: #9333ea;
            border-radius: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 10px 25px rgba(147, 51, 234, 0.3);
        }
        
        .header-icon svg {
            width: 2rem;
            height: 2rem;
            color: white;
        }
        
        h1 {
            font-size: 1.875rem;
            color: white;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            color: #c4b5fd;
            font-size: 0.875rem;
        }
        
        .main-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border-radius: 1.5rem;
            padding: 1.5rem;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 2rem;
        }
        
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        label {
            display: block;
            color: #ddd6fe;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
        
        label svg {
            width: 1rem;
            height: 1rem;
            display: inline;
            margin-right: 0.25rem;
            vertical-align: middle;
        }
        
        select, input[type="text"], input[type="number"] {
            width: 100%;
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(147, 51, 234, 0.3);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            color: white;
            font-size: 1rem;
            outline: none;
            transition: all 0.2s;
        }
        
        select:focus, input:focus {
            border-color: #9333ea;
            box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.3);
        }
        
        .time-adjust {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .time-adjust input {
            flex: 1;
            min-width: 60px;
            text-align: center;
        }
        
        .btn-adjust {
            background: #334155;
            color: white;
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.875rem;
            transition: background 0.2s;
        }
        
        .btn-adjust:hover {
            background: #475569;
        }
        
        .time-adjust-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
        }
        
        .text-xs {
            font-size: 0.75rem;
        }
        
        .text-purple-400 {
            color: #c084fc;
        }
        
        .text-pink-400 {
            color: #f472b6;
        }
        
        .text-green-400 {
            color: #4ade80;
        }
        
        .reset-btn {
            background: none;
            border: none;
            color: #f472b6;
            cursor: pointer;
            font-size: 0.75rem;
        }
        
        .reset-btn:hover {
            color: #f9a8d4;
        }
        
        .current-time {
            text-align: center;
            margin-bottom: 1.5rem;
        }
        
        .current-time p:first-child {
            color: #c4b5fd;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .current-time .time {
            font-size: 1.5rem;
            color: white;
            font-family: monospace;
        }
        
        .current-time .source {
            font-size: 0.75rem;
            color: #c084fc;
            margin-top: 0.25rem;
        }
        
        .code-display-container {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(219, 39, 119, 0.2));
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(147, 51, 234, 0.3);
        }
        
        .code-display-container > p {
            color: #c4b5fd;
            font-size: 0.875rem;
            text-align: center;
            margin-bottom: 0.75rem;
        }
        
        .code-display {
            font-size: 3rem;
            font-family: monospace;
            font-weight: bold;
            text-align: center;
            color: white;
            letter-spacing: 0.3em;
            margin-bottom: 1rem;
        }
        
        .progress-container {
            position: relative;
        }
        
        .progress-bar-bg {
            height: 0.5rem;
            background: #334155;
            border-radius: 9999px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #9333ea, #ec4899);
            border-radius: 9999px;
            transition: width 1s linear;
        }
        
        .progress-bar.warning {
            background: linear-gradient(90deg, #ef4444, #f97316);
        }
        
        .progress-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }
        
        .progress-footer span:first-child {
            color: #c084fc;
        }
        
        .progress-footer span:last-child {
            color: #c4b5fd;
            font-family: monospace;
        }
        
        .copy-btn {
            width: 100%;
            background: linear-gradient(90deg, #9333ea, #ec4899);
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-size: 1rem;
            transition: all 0.2s;
            box-shadow: 0 10px 25px rgba(147, 51, 234, 0.3);
            margin-bottom: 1.5rem;
        }
        
        .copy-btn:hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }
        
        .copy-btn:active {
            transform: scale(0.98);
        }
        
        .copy-btn svg {
            width: 1.25rem;
            height: 1.25rem;
        }
        
        .code-list-section {
            border-top: 1px solid rgba(147, 51, 234, 0.3);
            padding-top: 1.5rem;
        }
        
        .code-list-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .code-list-header p {
            color: #c4b5fd;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .code-list-header p svg {
            width: 1rem;
            height: 1rem;
            display: inline;
            margin-right: 0.25rem;
            vertical-align: middle;
        }
        
        .code-list-header span {
            font-size: 0.75rem;
            color: #c084fc;
        }
        
        .code-list {
            max-height: 24rem;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        
        .code-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .code-list::-webkit-scrollbar-track {
            background: rgba(100, 100, 150, 0.1);
            border-radius: 3px;
        }
        
        .code-list::-webkit-scrollbar-thumb {
            background: rgba(147, 51, 234, 0.5);
            border-radius: 3px;
        }
        
        .code-list::-webkit-scrollbar-thumb:hover {
            background: rgba(147, 51, 234, 0.7);
        }
        
        .code-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border-radius: 0.75rem;
            border: 1px solid rgba(71, 85, 105, 0.3);
            background: rgba(30, 41, 59, 0.3);
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 0.25rem;
        }
        
        .code-row:hover {
            background: rgba(147, 51, 234, 0.3);
        }
        
        .code-row.current {
            background: linear-gradient(90deg, rgba(147, 51, 234, 0.4), rgba(219, 39, 119, 0.4));
            border-color: rgba(147, 51, 234, 0.5);
            transform: scale(1.02);
        }
        
        .code-row.past {
            opacity: 0.6;
        }
        
        .code-row.copied {
            background: rgba(34, 197, 94, 0.5) !important;
        }
        
        .code-row-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .code-row-offset {
            font-size: 0.75rem;
            font-family: monospace;
            width: 3rem;
            color: #c084fc;
        }
        
        .code-row-offset.current {
            color: #f9a8d4;
            font-weight: bold;
        }
        
        .code-row-time {
            font-size: 0.75rem;
            font-family: monospace;
            color: #c084fc;
        }
        
        .code-row-code {
            font-family: monospace;
            font-weight: bold;
            letter-spacing: 0.1em;
            color: #ddd6fe;
        }
        
        .code-row-code.current {
            color: white;
            font-size: 1.125rem;
        }
        
        .info-footer {
            margin-top: 1.5rem;
            text-align: center;
            color: #c084fc;
            font-size: 0.875rem;
        }
        
        .error-message {
            text-align: center;
            color: #f87171;
            padding: 1rem;
        }
        
        .empty-message {
            text-align: center;
            color: #c084fc;
            padding: 2rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="text-center">
            <div class="header-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                </svg>
            </div>
            <h1>TOTP Authenticator</h1>
            <p class="subtitle">SHA1 • 6 Digits • 30 Seconds</p>
        </div>

        <!-- Main Card -->
        <div class="main-card">
            <!-- Timezone Selector -->
            <div class="form-group">
                <label>
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    Timezone
                </label>
                <select id="timezone"></select>
            </div>

            <!-- Time Adjustment -->
            <div class="form-group">
                <label>
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    Time Adjustment (seconds)
                </label>
                <div class="time-adjust">
                    <button class="btn-adjust" onclick="adjustTime(-30)">-30s</button>
                    <button class="btn-adjust" onclick="adjustTime(-5)">-5s</button>
                    <button class="btn-adjust" onclick="adjustTime(-1)">-1s</button>
                    <input type="number" id="timeOffset" value="0">
                    <button class="btn-adjust" onclick="adjustTime(1)">+1s</button>
                    <button class="btn-adjust" onclick="adjustTime(5)">+5s</button>
                    <button class="btn-adjust" onclick="adjustTime(30)">+30s</button>
                </div>
                <div class="time-adjust-footer">
                    <span class="text-xs text-purple-400">Adjust if your device clock is off</span>
                    <button class="reset-btn" onclick="resetTime()">Reset to 0</button>
                </div>
            </div>

            <!-- Current Time Display -->
            <div class="current-time">
                <p>Current Time (from device + adjustment)</p>
                <p id="currentTime" class="time">--:--:--</p>
                <p id="timeSource" class="source">Using device time</p>
            </div>

            <!-- Secret Key Input -->
            <div class="form-group">
                <label>
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"></path>
                    </svg>
                    Secret Key (Base32)
                </label>
                <input 
                    type="text" 
                    id="secretKey" 
                    value="6j776hwyhpmznvcs"
                    placeholder="Enter your secret key (e.g., JBSWY3DPEHPK3PXP)"
                    class="font-mono"
                >
                <p class="text-xs text-purple-400" style="margin-top: 0.5rem;">Enter the Base32 encoded secret key from your service</p>
            </div>

            <!-- Current Code Display -->
            <div class="code-display-container">
                <p>Current Authentication Code</p>
                <div id="codeDisplay" class="code-display">--- ---</div>
                
                <!-- Progress Bar -->
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div id="progressBar" class="progress-bar" style="width: 100%"></div>
                    </div>
                    <div class="progress-footer">
                        <span>Refreshes in</span>
                        <span id="countdown">30s</span>
                    </div>
                </div>
            </div>

            <!-- Copy Button -->
            <button id="copyBtn" onclick="copyCode()" class="copy-btn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
                <span id="copyText">Copy Code</span>
            </button>

            <!-- Code List -->
            <div class="code-list-section">
                <div class="code-list-header">
                    <p>
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16"></path>
                        </svg>
                        Code Timeline (±20 codes)
                    </p>
                    <span>Click any code to copy</span>
                </div>
                <div id="codeList" class="code-list">
                    <!-- Codes will be populated here -->
                </div>
            </div>
        </div>

        <!-- Info Section -->
        <div class="info-footer">
            <p>Algorithm: SHA-1 | Digits: 6 | Period: 30s</p>
        </div>
    </div>

    <script>
        // ===== Pure JavaScript SHA-1 and HMAC-SHA1 Implementation =====
        
        function sha1(message) {
            // Convert message to bytes if it's a Uint8Array
            let msg;
            if (message instanceof Uint8Array) {
                msg = message;
            } else {
                msg = new TextEncoder().encode(message);
            }
            
            // Pre-processing
            const msgLen = msg.length;
            const msgBitLen = msgLen * 8;
            
            // Padding
            const padLen = (msgLen % 64 < 56) ? (56 - msgLen % 64) : (120 - msgLen % 64);
            const paddedMsg = new Uint8Array(msgLen + padLen + 8);
            paddedMsg.set(msg);
            paddedMsg[msgLen] = 0x80;
            
            // Append length in bits as 64-bit big-endian
            const view = new DataView(paddedMsg.buffer);
            view.setUint32(paddedMsg.length - 4, msgBitLen, false);
            
            // Initialize hash values
            let h0 = 0x67452301;
            let h1 = 0xEFCDAB89;
            let h2 = 0x98BADCFE;
            let h3 = 0x10325476;
            let h4 = 0xC3D2E1F0;
            
            // Process each 512-bit block
            const w = new Uint32Array(80);
            
            for (let offset = 0; offset < paddedMsg.length; offset += 64) {
                // Break block into 16 32-bit big-endian words
                for (let i = 0; i < 16; i++) {
                    w[i] = (paddedMsg[offset + i * 4] << 24) |
                           (paddedMsg[offset + i * 4 + 1] << 16) |
                           (paddedMsg[offset + i * 4 + 2] << 8) |
                           (paddedMsg[offset + i * 4 + 3]);
                }
                
                // Extend the 16 32-bit words into 80 32-bit words
                for (let i = 16; i < 80; i++) {
                    const val = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
                    w[i] = (val << 1) | (val >>> 31);
                }
                
                // Initialize working variables
                let a = h0, b = h1, c = h2, d = h3, e = h4;
                
                // Main loop
                for (let i = 0; i < 80; i++) {
                    let f, k;
                    if (i < 20) {
                        f = (b & c) | ((~b) & d);
                        k = 0x5A827999;
                    } else if (i < 40) {
                        f = b ^ c ^ d;
                        k = 0x6ED9EBA1;
                    } else if (i < 60) {
                        f = (b & c) | (b & d) | (c & d);
                        k = 0x8F1BBCDC;
                    } else {
                        f = b ^ c ^ d;
                        k = 0xCA62C1D6;
                    }
                    
                    const temp = (((a << 5) | (a >>> 27)) + f + e + k + w[i]) >>> 0;
                    e = d;
                    d = c;
                    c = ((b << 30) | (b >>> 2)) >>> 0;
                    b = a;
                    a = temp;
                }
                
                // Add to hash
                h0 = (h0 + a) >>> 0;
                h1 = (h1 + b) >>> 0;
                h2 = (h2 + c) >>> 0;
                h3 = (h3 + d) >>> 0;
                h4 = (h4 + e) >>> 0;
            }
            
            // Produce the final hash value (160 bits = 20 bytes)
            const hash = new Uint8Array(20);
            const hashView = new DataView(hash.buffer);
            hashView.setUint32(0, h0, false);
            hashView.setUint32(4, h1, false);
            hashView.setUint32(8, h2, false);
            hashView.setUint32(12, h3, false);
            hashView.setUint32(16, h4, false);
            
            return hash;
        }
        
        function hmacSha1(key, message) {
            const blockSize = 64;
            let keyBytes;
            
            if (key instanceof Uint8Array) {
                keyBytes = key;
            } else {
                keyBytes = new TextEncoder().encode(key);
            }
            
            // If key is longer than block size, hash it
            if (keyBytes.length > blockSize) {
                keyBytes = sha1(keyBytes);
            }
            
            // Pad key to block size
            const paddedKey = new Uint8Array(blockSize);
            paddedKey.set(keyBytes);
            
            // Create inner and outer padding
            const ipad = new Uint8Array(blockSize);
            const opad = new Uint8Array(blockSize);
            
            for (let i = 0; i < blockSize; i++) {
                ipad[i] = paddedKey[i] ^ 0x36;
                opad[i] = paddedKey[i] ^ 0x5c;
            }
            
            // Get message bytes
            let msgBytes;
            if (message instanceof Uint8Array) {
                msgBytes = message;
            } else {
                msgBytes = new TextEncoder().encode(message);
            }
            
            // Inner hash: SHA1(ipad || message)
            const innerData = new Uint8Array(blockSize + msgBytes.length);
            innerData.set(ipad);
            innerData.set(msgBytes, blockSize);
            const innerHash = sha1(innerData);
            
            // Outer hash: SHA1(opad || innerHash)
            const outerData = new Uint8Array(blockSize + 20);
            outerData.set(opad);
            outerData.set(innerHash, blockSize);
            
            return sha1(outerData);
        }
        
        // ===== TOTP Implementation =====
        
        // Populate timezone dropdown
        const timezones = Intl.supportedValuesOf('timeZone');
        const timezoneSelect = document.getElementById('timezone');
        const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        timezones.forEach(tz => {
            const option = document.createElement('option');
            option.value = tz;
            option.textContent = tz.replace(/_/g, ' ');
            if (tz === userTimezone) {
                option.selected = true;
            }
            timezoneSelect.appendChild(option);
        });

        // Base32 decode function
        function base32Decode(input) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let bits = '';
            let output = [];
            
            // Clean input
            input = input.toUpperCase().replace(/[^A-Z2-7]/g, '');
            
            for (let i = 0; i < input.length; i++) {
                const val = alphabet.indexOf(input[i]);
                if (val === -1) continue;
                bits += val.toString(2).padStart(5, '0');
            }
            
            for (let i = 0; i + 8 <= bits.length; i += 8) {
                output.push(parseInt(bits.substring(i, i + 8), 2));
            }
            
            return new Uint8Array(output);
        }

        // Generate TOTP for a specific counter value
        function generateTOTPForCounter(secret, counter, digits = 6) {
            try {
                const key = base32Decode(secret);
                if (key.length === 0) return null;
                
                // Convert counter to 8-byte array (big-endian)
                const counterBytes = new Uint8Array(8);
                let temp = counter;
                for (let i = 7; i >= 0; i--) {
                    counterBytes[i] = temp & 0xff;
                    temp = Math.floor(temp / 256);
                }
                
                // Generate HMAC-SHA1
                const hmac = hmacSha1(key, counterBytes);
                
                // Dynamic truncation
                const offset = hmac[hmac.length - 1] & 0x0f;
                const binary = 
                    ((hmac[offset] & 0x7f) << 24) |
                    ((hmac[offset + 1] & 0xff) << 16) |
                    ((hmac[offset + 2] & 0xff) << 8) |
                    (hmac[offset + 3] & 0xff);
                
                // Generate OTP
                const otp = binary % Math.pow(10, digits);
                return otp.toString().padStart(digits, '0');
            } catch (e) {
                console.error('Error generating TOTP:', e);
                return null;
            }
        }

        // Generate TOTP for current time
        function generateTOTP(secret, timeStep = 30, digits = 6) {
            const epoch = Math.floor(getAccurateTime() / 1000);
            const counter = Math.floor(epoch / timeStep);
            return generateTOTPForCounter(secret, counter, digits);
        }

        // Generate list of codes (past and future)
        function generateCodeList(secret, pastCount = 20, futureCount = 20, timeStep = 30) {
            const codes = [];
            const epoch = Math.floor(getAccurateTime() / 1000);
            const currentCounter = Math.floor(epoch / timeStep);
            
            for (let i = -pastCount; i <= futureCount; i++) {
                const counter = currentCounter + i;
                const code = generateTOTPForCounter(secret, counter);
                const timeStart = counter * timeStep;
                const timeEnd = (counter + 1) * timeStep;
                
                codes.push({
                    code: code,
                    counter: counter,
                    offset: i,
                    timeStart: timeStart,
                    timeEnd: timeEnd,
                    isCurrent: i === 0
                });
            }
            
            return codes;
        }

        // Format time from epoch seconds
        function formatTime(epochSeconds, timezone) {
            const date = new Date(epochSeconds * 1000);
            return date.toLocaleTimeString('en-US', {
                timeZone: timezone,
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // Copy a specific code
        function copySpecificCode(code, element) {
            navigator.clipboard.writeText(code).then(() => {
                // Show brief feedback
                if (element) {
                    element.classList.add('copied');
                    setTimeout(() => {
                        element.classList.remove('copied');
                    }, 300);
                }
            });
        }

        // Update display
        function updateDisplay() {
            const timezone = document.getElementById('timezone').value;
            const secret = document.getElementById('secretKey').value.trim();
            
            // Update current time using device time + manual adjustment
            const accurateNow = new Date(getAccurateTime());
            const timeString = accurateNow.toLocaleTimeString('en-US', { 
                timeZone: timezone,
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('currentTime').textContent = timeString;
            
            // Update time source info
            const timeSource = document.getElementById('timeSource');
            if (manualTimeOffset === 0) {
                timeSource.textContent = 'Using device time';
                timeSource.className = 'source';
            } else {
                const sign = manualTimeOffset > 0 ? '+' : '';
                timeSource.textContent = `Device time ${sign}${manualTimeOffset}s`;
                timeSource.className = 'source text-green-400';
            }
            
            // Calculate time remaining using accurate time
            const epoch = Math.floor(getAccurateTime() / 1000);
            const timeRemaining = 30 - (epoch % 30);
            const progress = (timeRemaining / 30) * 100;
            
            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('countdown').textContent = timeRemaining + 's';
            
            // Change progress bar color when low
            const progressBar = document.getElementById('progressBar');
            if (timeRemaining <= 5) {
                progressBar.classList.add('warning');
            } else {
                progressBar.classList.remove('warning');
            }
            
            // Generate and display code
            const codeList = document.getElementById('codeList');
            
            if (secret) {
                const code = generateTOTP(secret);
                if (code) {
                    document.getElementById('codeDisplay').textContent = code.substring(0, 3) + ' ' + code.substring(3);
                    
                    // Generate code list
                    const codes = generateCodeList(secret, 20, 20);
                    let listHTML = '';
                    
                    codes.forEach(item => {
                        if (!item.code) return;
                        
                        const timeStartStr = formatTime(item.timeStart, timezone);
                        const formattedCode = item.code.substring(0, 3) + ' ' + item.code.substring(3);
                        
                        let offsetLabel = '';
                        if (item.offset < 0) {
                            offsetLabel = `${item.offset * 30}s`;
                        } else if (item.offset > 0) {
                            offsetLabel = `+${item.offset * 30}s`;
                        } else {
                            offsetLabel = 'NOW';
                        }
                        
                        let rowClass = 'code-row';
                        if (item.isCurrent) rowClass += ' current';
                        else if (item.offset < 0) rowClass += ' past';
                        
                        const offsetClass = item.isCurrent ? 'code-row-offset current' : 'code-row-offset';
                        const codeClass = item.isCurrent ? 'code-row-code current' : 'code-row-code';
                        
                        listHTML += `
                            <div class="${rowClass}" onclick="copySpecificCode('${item.code}', this)">
                                <div class="code-row-left">
                                    <span class="${offsetClass}">${offsetLabel}</span>
                                    <span class="code-row-time">${timeStartStr}</span>
                                </div>
                                <span class="${codeClass}">${formattedCode}</span>
                            </div>
                        `;
                    });
                    
                    codeList.innerHTML = listHTML;
                    
                    // Scroll to current code (centered)
                    const currentRow = codeList.querySelector('.code-row.current');
                    if (currentRow && !codeList.dataset.scrolled) {
                        setTimeout(() => {
                            currentRow.scrollIntoView({ block: 'center', behavior: 'auto' });
                            codeList.dataset.scrolled = 'true';
                        }, 100);
                    }
                } else {
                    document.getElementById('codeDisplay').textContent = 'Invalid';
                    codeList.innerHTML = '<p class="error-message">Invalid secret key</p>';
                }
            } else {
                document.getElementById('codeDisplay').textContent = '--- ---';
                codeList.innerHTML = '<p class="empty-message">Enter a secret key to see codes</p>';
            }
        }

        // Copy code to clipboard
        function copyCode() {
            const codeDisplay = document.getElementById('codeDisplay').textContent;
            const code = codeDisplay.replace(/\s/g, '');
            
            if (code && code !== '------' && code !== 'Invalid') {
                navigator.clipboard.writeText(code).then(() => {
                    const copyText = document.getElementById('copyText');
                    const originalText = copyText.textContent;
                    copyText.textContent = 'Copied!';
                    setTimeout(() => {
                        copyText.textContent = originalText;
                    }, 1500);
                });
            }
        }

        // Event listeners
        document.getElementById('secretKey').addEventListener('input', updateDisplay);
        document.getElementById('timezone').addEventListener('change', updateDisplay);

        // Manual time offset in seconds
        let manualTimeOffset = 0;

        // Load saved offset from localStorage
        function loadSavedOffset() {
            const saved = localStorage.getItem('totpTimeOffset');
            if (saved !== null) {
                manualTimeOffset = parseInt(saved, 10) || 0;
                document.getElementById('timeOffset').value = manualTimeOffset;
            }
        }

        // Save offset to localStorage
        function saveOffset() {
            localStorage.setItem('totpTimeOffset', manualTimeOffset.toString());
        }

        // Adjust time by seconds
        function adjustTime(seconds) {
            manualTimeOffset += seconds;
            document.getElementById('timeOffset').value = manualTimeOffset;
            saveOffset();
            updateDisplay();
        }

        // Reset time offset
        function resetTime() {
            manualTimeOffset = 0;
            document.getElementById('timeOffset').value = 0;
            saveOffset();
            updateDisplay();
        }

        // Handle manual input in the offset field
        document.getElementById('timeOffset').addEventListener('input', function(e) {
            const val = parseInt(e.target.value, 10);
            if (!isNaN(val)) {
                manualTimeOffset = val;
                saveOffset();
                updateDisplay();
            }
        });

        // Get current time with manual adjustment
        function getAccurateTime() {
            return Date.now() + (manualTimeOffset * 1000);
        }

        // Track current counter to detect changes
        let lastCounter = null;

        // Wrapper to reset scroll on counter change
        function updateWithScrollReset() {
            const epoch = Math.floor(getAccurateTime() / 1000);
            const currentCounter = Math.floor(epoch / 30);
            
            if (lastCounter !== null && lastCounter !== currentCounter) {
                // Counter changed, reset scroll flag
                const codeList = document.getElementById('codeList');
                if (codeList) {
                    delete codeList.dataset.scrolled;
                }
            }
            lastCounter = currentCounter;
            
            updateDisplay();
        }

        // Load saved offset on startup
        loadSavedOffset();

        // Initial update and interval
        updateWithScrollReset();
        setInterval(updateWithScrollReset, 1000);
    </script>
</body>
</html>
